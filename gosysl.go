package gosysl

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"sort"
	"strings"

	"github.com/anz-bank/gosysl/pb"
)

// CodeResult contains source files' contents as []byte
type CodeResult struct {
	Rest       []byte
	Storer     []byte
	Middleware []byte
}

// Generate creates CodeResult for given Sysl definitions as Proto message (pb.Module)
func Generate(module *pb.Module, pkg string) (CodeResult, error) {
	app, err := getApp(module)
	if err != nil {
		return CodeResult{}, err
	}
	epNames := sortEpNames(app.Endpoints)
	interf, err := genInterfaceFile(app, epNames, pkg)
	if err != nil {
		return CodeResult{}, err
	}
	middleware, err := genMiddlewareFile(app, epNames, pkg)
	if err != nil {
		return CodeResult{}, err
	}
	rest, err := genRestFile(app, epNames, pkg)
	if err != nil {
		return CodeResult{}, err
	}
	result := CodeResult{
		Rest:       rest,
		Storer:     interf,
		Middleware: middleware,
	}
	return result, nil
}

func genRestFile(app *pb.Application, epNames []string, pkg string) ([]byte, error) {
	buffer := &bytes.Buffer{}
	fmt.Fprintf(buffer, autoGenPrefix, pkg)
	fmt.Fprintf(buffer, "package %s\n\n", pkg)
	fmt.Fprintln(buffer, restPrefix)
	if err := WriteRest(buffer, app, epNames); err != nil {
		return nil, err
	}
	return format.Source(buffer.Bytes())
}

func genInterfaceFile(app *pb.Application, epNames []string, pkg string) ([]byte, error) {
	buffer := &bytes.Buffer{}
	fmt.Fprintf(buffer, autoGenPrefix, pkg)
	fmt.Fprintf(buffer, "package %s\n\n", pkg)
	if err := WriteInterface(buffer, app, epNames); err != nil {
		return nil, err
	}
	if err := WriteTypes(buffer, app); err != nil {
		return nil, err
	}
	return format.Source(buffer.Bytes())
}

func genMiddlewareFile(app *pb.Application, eps []string, pkg string) ([]byte, error) {
	buffer := &bytes.Buffer{}
	fmt.Fprintf(buffer, autoGenPrefix, pkg)
	fmt.Fprintf(buffer, "package %s\n\n", pkg)
	fmt.Fprint(buffer, `import "net/http"`+"\n\n")
	WriteMiddleware(buffer, app, eps)
	return format.Source(buffer.Bytes())
}

func getApp(module *pb.Module) (*pb.Application, error) {
	apps := module.GetApps()
	if len(apps) > 1 {
		return nil, fmt.Errorf("cannot handle more than 1 application")
	}
	for _, app := range apps {
		return app, nil
	}
	return nil, fmt.Errorf("need at least 1 application")
}

// GetPackage extracts package name from output directory
func GetPackage(outDir string) string {
	dirs, last := filepath.Split(outDir)
	if last == "" {
		dirs = filepath.Dir(dirs)
		_, last = filepath.Split(dirs)
	}
	return last
}

// LineName contains name, such as type or endpoint name and corresponding line
type LineName struct {
	name string
	line int32
}

// SortLineNames sorts a slice of LineName in place and returns a slice of
// sorted names
func SortLineNames(lineNames []LineName) []string {
	sort.Slice(lineNames, func(i, j int) bool {
		return lineNames[i].line < lineNames[j].line
	})
	size := len(lineNames)
	result := make([]string, size)
	for i := 0; i < size; i++ {
		result[i] = lineNames[i].name
	}
	return result
}

func getEndpointLine(ep *pb.Endpoint) int32 {
	if ep.RestParams == nil {
		return 0
	}
	params := ep.RestParams.QueryParam
	if len(params) == 0 {
		if strings.HasPrefix(strings.ToLower(ep.Name), "get") {
			return -1
		}
		return 0
	}
	return params[0].Type.SourceContext.Start.Line
}

func sortEpNames(endpoints map[string]*pb.Endpoint) []string {
	lineNames := make([]LineName, len(endpoints))
	i := 0
	for name, t := range endpoints {
		line := getEndpointLine(t)
		lineNames[i] = LineName{name, line}
		i++
	}
	return SortLineNames(lineNames)
}

const autoGenPrefix = `// Package %s is partly autogenerated.
// This file is AUTOGENERATED -  DO NOT EDIT!
`

const restPrefix = `import (
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"net/http"

	"github.com/go-chi/chi"
	"github.com/go-chi/render"
)

// RestHandler implements Handler and contains all routes for RefData REST API.
type RestHandler struct {
	storer Storer
	router *chi.Mux
}

func (rh *RestHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	rh.router.ServeHTTP(w, r)
}

// StatusError extends the error interface to hold a http.Status
type StatusError interface {
	Error() string
	Status() int
}

func getStatus(err error) int {
	if statusErr, ok := err.(StatusError); ok {
		return statusErr.Status()
	}
	return http.StatusInternalServerError
}

// ContextKeyType is the enum type for keys in Context
type ContextKeyType int

func makeContextSaver(k ContextKeyType, urlParam string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			up := chi.URLParam(r, urlParam)
			ctx := context.WithValue(r.Context(), k, up)
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

func decodeJSON(r io.Reader, v interface{}) error {
	defer io.Copy(ioutil.Discard, r) // nolint: errcheck
	return json.NewDecoder(r).Decode(v)
}
`
